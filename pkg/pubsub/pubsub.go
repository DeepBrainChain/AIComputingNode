package ps

import (
	"context"
	"encoding/json"
	"path/filepath"
	"time"

	"AIComputingNode/pkg/config"
	"AIComputingNode/pkg/ipfs"
	"AIComputingNode/pkg/log"
	"AIComputingNode/pkg/p2p"
	"AIComputingNode/pkg/protocol"
	"AIComputingNode/pkg/serve"

	"google.golang.org/protobuf/proto"

	pubsub "github.com/libp2p/go-libp2p-pubsub"
)

var MsgNotSupported string = "Not supported"

func PublishToTopic(ctx context.Context, topic *pubsub.Topic, messageChan <-chan []byte) {
	for message := range messageChan {
		if err := topic.Publish(ctx, message); err != nil {
			log.Logger.Errorf("Error when publish to topic %v", err)
		} else {
			log.Logger.Infof("Published %d bytes", len(message))
		}
	}
}

func PubsubHandler(ctx context.Context, sub *pubsub.Subscription, publishChan chan<- []byte) {
	defer sub.Cancel()
	for {
		msg, err := sub.Next(ctx)
		if err != nil {
			log.Logger.Warnf("Read PubSub: %v", err)
			continue
		}

		pmsg := &protocol.Message{}
		err = proto.Unmarshal(msg.Data, pmsg)
		if err != nil {
			log.Logger.Warnf("Unmarshal PubSub: %v", err)
			continue
		}

		if pmsg.Header.NodeId == config.GC.Identity.PeerID {
			log.Logger.Infof("Received message type %s from the node itself", pmsg.Type)
			continue
		} else if pmsg.Header.Receiver != config.GC.Identity.PeerID {
			log.Logger.Infof("Gossip message type %s from %s to %s", pmsg.Type, pmsg.Header.NodeId, pmsg.Header.Receiver)
			continue
		} else {
			log.Logger.Infof("Received message type %s from %s", pmsg.Type, pmsg.Header.NodeId)
		}

		switch pmsg.Type {
		case protocol.MessageType_PEER_IDENTITY:
			if pi := pmsg.GetPi(); pi != nil {
				if piReq := pi.GetReq(); piReq != nil {
					if piReq.GetNodeId() == config.GC.Identity.PeerID {
						idp := p2p.Hio.GetIdentifyProtocol()
						res := protocol.Message{
							Header: &protocol.MessageHeader{
								ClientVersion: p2p.Hio.UserAgent,
								Timestamp:     time.Now().Unix(),
								Id:            pmsg.Header.Id,
								NodeId:        config.GC.Identity.PeerID,
								Receiver:      pmsg.Header.NodeId,
							},
							Type: protocol.MessageType_PEER_IDENTITY,
							Body: &protocol.Message_Pi{
								Pi: &protocol.PeerIdentityBody{
									Data: &protocol.PeerIdentityBody_Res{
										Res: &protocol.PeerIdentityResponse{
											ProtocolVersion: idp.ProtocolVersion,
											AgentVersion:    idp.AgentVersion,
											ListenAddrs:     idp.Addresses,
											Protocols:       idp.Protocols,
										},
									},
								},
							},
						}
						resBytes, err := proto.Marshal(&res)
						if err != nil {
							log.Logger.Warnf("Marshal Identity Response %v", err)
							break
						}
						publishChan <- resBytes
						log.Logger.Info("Sending Peer Identity Response")
					} else {
						log.Logger.Info("Gossip Peer Identity Request of ", piReq.GetNodeId())
					}
				} else if piRes := pi.GetRes(); piRes != nil {
					res := serve.PeerResponse{
						Code:    0,
						Message: "ok",
						Data: p2p.IdentifyProtocol{
							ID:              pmsg.Header.NodeId,
							ProtocolVersion: piRes.ProtocolVersion,
							AgentVersion:    piRes.AgentVersion,
							Addresses:       piRes.ListenAddrs,
							Protocols:       piRes.Protocols,
						},
					}
					notifyData, err := json.Marshal(res)
					if err != nil {
						log.Logger.Warnf("Marshal Identity Protocol %v", err)
						break
					}
					serve.WriteAndDeleteRequestItem(pmsg.Header.Id, notifyData)
				}
			} else if ustd := pmsg.GetUnsupported(); ustd != nil {
				res := serve.PeerResponse{
					Code:    serve.ErrCodeUnsupported,
					Message: MsgNotSupported,
					Data:    p2p.IdentifyProtocol{},
				}
				notifyData, err := json.Marshal(res)
				if err != nil {
					log.Logger.Warnf("Marshal Identity Protocol %v", err)
					break
				}
				serve.WriteAndDeleteRequestItem(pmsg.Header.Id, notifyData)
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		case protocol.MessageType_IMAGE_GENERATION:
			if ig := pmsg.GetIg(); ig != nil {
				if igReq := ig.GetReq(); igReq != nil {
					if igReq.GetNodeId() == config.GC.Identity.PeerID {
						// TODO: Run the model and upload the images generated by the model to the IPFS node
						var ipfsAddr string = "/ip4/192.168.1.159/tcp/4002"
						var filePath string = "D:\\Code\\AIComputingNode\\tools\\ipfs\\tux.png"
						cid, code, err := ipfs.UploadImage(ctx, ipfsAddr, filePath)
						var msg string = "ok"
						if err != nil {
							msg = err.Error()
							log.Logger.Errorf("Failed to upload image %s to ipfs endpoint %s", filePath, ipfsAddr)
						}
						res := protocol.Message{
							Header: &protocol.MessageHeader{
								ClientVersion: p2p.Hio.UserAgent,
								Timestamp:     time.Now().Unix(),
								Id:            pmsg.Header.Id,
								NodeId:        config.GC.Identity.PeerID,
								Receiver:      pmsg.Header.NodeId,
							},
							Type: protocol.MessageType_IMAGE_GENERATION,
							Body: &protocol.Message_Ig{
								Ig: &protocol.ImageGenerationBody{
									Data: &protocol.ImageGenerationBody_Res{
										Res: &protocol.ImageGenerationResponse{
											Code:      int32(code),
											Message:   msg,
											IpfsNode:  ipfsAddr,
											Cid:       cid,
											ImageName: filepath.Base(filePath),
										},
									},
								},
							},
						}
						resBytes, err := proto.Marshal(&res)
						if err != nil {
							log.Logger.Errorf("Marshal Image Generation Response %v", err)
							break
						}
						publishChan <- resBytes
						log.Logger.Info("Sending Image Generation Response")
					} else {
						log.Logger.Info("Gossip Image Generation Request of ", igReq.GetNodeId())
					}
				} else if igRes := ig.GetRes(); igRes != nil {
					res := serve.ImageGenerationResponse{
						Code:    int(igRes.Code),
						Message: igRes.Message,
					}
					if igRes.Code == 0 {
						res.Data.IpfsNode = igRes.IpfsNode
						res.Data.CID = igRes.Cid
						res.Data.ImageName = igRes.ImageName
					}
					notifyData, err := json.Marshal(res)
					if err != nil {
						log.Logger.Warnf("Marshal Image Generation Response %v", err)
						break
					}
					serve.WriteAndDeleteRequestItem(pmsg.Header.Id, notifyData)
				}
			} else if ustd := pmsg.GetUnsupported(); ustd != nil {
				res := serve.ImageGenerationResponse{
					Code:    serve.ErrCodeUnsupported,
					Message: MsgNotSupported,
				}
				notifyData, err := json.Marshal(res)
				if err != nil {
					log.Logger.Warnf("Marshal Identity Protocol %v", err)
					break
				}
				serve.WriteAndDeleteRequestItem(pmsg.Header.Id, notifyData)
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		default:
			res := protocol.Message{
				Header: &protocol.MessageHeader{
					ClientVersion: p2p.Hio.UserAgent,
					Timestamp:     time.Now().Unix(),
					Id:            pmsg.Header.Id,
					NodeId:        config.GC.Identity.PeerID,
					Receiver:      pmsg.Header.NodeId,
				},
				Type: pmsg.Type,
				Body: &protocol.Message_Unsupported{
					Unsupported: &protocol.UnsupportedBody{
						Message: MsgNotSupported,
					},
				},
			}
			resBytes, err := proto.Marshal(&res)
			if err != nil {
				log.Logger.Errorf("Marshal Image Generation Response %v", err)
				break
			}
			publishChan <- resBytes
			log.Logger.Warnf("Unknowned message type", pmsg.Type)
		}
	}
}
