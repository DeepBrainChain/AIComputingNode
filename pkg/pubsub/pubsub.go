package ps

import (
	"context"
	"encoding/json"
	"path/filepath"
	"time"

	"AIComputingNode/pkg/config"
	"AIComputingNode/pkg/ipfs"
	"AIComputingNode/pkg/log"
	"AIComputingNode/pkg/p2p"
	"AIComputingNode/pkg/protocol"
	"AIComputingNode/pkg/serve"

	"google.golang.org/protobuf/proto"

	pubsub "github.com/libp2p/go-libp2p-pubsub"
)

func PublishToTopic(ctx context.Context, topic *pubsub.Topic, messageChan <-chan []byte) {
	for message := range messageChan {
		if err := topic.Publish(ctx, message); err != nil {
			log.Logger.Errorf("Error when publish to topic %v", err)
		} else {
			log.Logger.Infof("Published %d bytes", len(message))
		}
	}
}

func PubsubHandler(ctx context.Context, sub *pubsub.Subscription, publishChan chan<- []byte) {
	defer sub.Cancel()
	for {
		msg, err := sub.Next(ctx)
		if err != nil {
			log.Logger.Warnf("Read PubSub: %v", err)
			continue
		}

		pmsg := &protocol.Message{}
		err = proto.Unmarshal(msg.Data, pmsg)
		if err != nil {
			log.Logger.Warnf("Unmarshal PubSub: %v", err)
			continue
		}

		if pmsg.Header.NodeId == config.GC.Identity.PeerID {
			log.Logger.Info("Received message type ", pmsg.Type, " from the node itself")
			continue
		} else {
			log.Logger.Info("Received message type ", pmsg.Type, " from ", pmsg.Header.NodeId)
		}

		switch pmsg.Type {
		case protocol.MesasgeType_PEER_IDENTITY_REQUEST:
			if piReq := pmsg.GetPiReq(); piReq != nil {
				if piReq.GetNodeId() == config.GC.Identity.PeerID {
					idp := p2p.Hio.GetIdentifyProtocol()
					res := protocol.Message{
						Header: &protocol.MessageHeader{
							ClientVersion: p2p.Hio.UserAgent,
							Timestamp:     time.Now().Unix(),
							Id:            pmsg.Header.Id,
							NodeId:        config.GC.Identity.PeerID,
						},
						Type: protocol.MesasgeType_PEER_IDENTITY_RESPONSE,
						Body: &protocol.Message_PiRes{
							PiRes: &protocol.PeerIdentityResponse{
								ProtocolVersion: idp.ProtocolVersion,
								AgentVersion:    idp.AgentVersion,
								PublicKey:       []byte(idp.PublicKey),
								ListenAddrs:     idp.Addresses,
								Protocols:       idp.Protocols,
							},
						},
					}
					resBytes, err := proto.Marshal(&res)
					if err != nil {
						log.Logger.Warnf("Marshal Identity Response %v", err)
						break
					}
					publishChan <- resBytes
					log.Logger.Info("Sending Peer Identity Response")
				} else {
					log.Logger.Info("Gossip Peer Identity Request of ", piReq.GetNodeId())
				}
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		case protocol.MesasgeType_PEER_IDENTITY_RESPONSE:
			if piRes := pmsg.GetPiRes(); piRes != nil {
				idp := p2p.IdentifyProtocol{
					ID:              pmsg.Header.NodeId,
					ProtocolVersion: piRes.ProtocolVersion,
					AgentVersion:    piRes.AgentVersion,
					PublicKey:       string(piRes.PublicKey),
					Addresses:       piRes.ListenAddrs,
					Protocols:       piRes.Protocols,
				}
				notifyData, err := json.Marshal(idp)
				if err != nil {
					log.Logger.Warnf("Marshal Identity Protocol %v", err)
					break
				}
				serve.QueueLock.Lock()
				for i, item := range serve.RequestQueue {
					if item.ID == pmsg.Header.Id {
						item.Notify <- notifyData
						serve.RequestQueue = append(serve.RequestQueue[:i], serve.RequestQueue[i+1:]...)
						close(item.Notify)
						break
					}
				}
				serve.QueueLock.Unlock()
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		case protocol.MesasgeType_IMAGE_GENERATION_REQUEST:
			if igReq := pmsg.GetIgReq(); igReq != nil {
				if igReq.GetNodeId() == config.GC.Identity.PeerID {
					// TODO: Run the model and upload the images generated by the model to the IPFS node
					var ipfsAddr string = "/ip4/192.168.1.159/tcp/4002"
					var filePath string = "D:\\Code\\AIComputingNode\\tools\\ipfs\\tux.png"
					cid, code, err := ipfs.UploadImage(ctx, ipfsAddr, filePath)
					var msg string = "ok"
					if err != nil {
						msg = err.Error()
						log.Logger.Errorf("Failed to upload image %s to ipfs endpoint %s", filePath, ipfsAddr)
					}
					res := protocol.Message{
						Header: &protocol.MessageHeader{
							ClientVersion: p2p.Hio.UserAgent,
							Timestamp:     time.Now().Unix(),
							Id:            pmsg.Header.Id,
							NodeId:        config.GC.Identity.PeerID,
						},
						Type: protocol.MesasgeType_IMAGE_GENERATION_RESPONSE,
						Body: &protocol.Message_IgRes{
							IgRes: &protocol.ImageGenerationResponse{
								Code:      int32(code),
								Message:   msg,
								IpfsNode:  ipfsAddr,
								Cid:       cid,
								ImageName: filepath.Base(filePath),
							},
						},
					}
					resBytes, err := proto.Marshal(&res)
					if err != nil {
						log.Logger.Errorf("Marshal Image Generation Response %v", err)
						break
					}
					publishChan <- resBytes
					log.Logger.Info("Sending Image Generation Response")
				} else {
					log.Logger.Info("Gossip Image Generation Request of ", igReq.GetNodeId())
				}
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		case protocol.MesasgeType_IMAGE_GENERATION_RESPONSE:
			if igRes := pmsg.GetIgRes(); igRes != nil {
				res := serve.ImageGenerationResponse{
					Code:    int(igRes.Code),
					Message: igRes.Message,
				}
				if igRes.Code == 0 {
					res.Data.IpfsNode = igRes.IpfsNode
					res.Data.CID = igRes.Cid
					res.Data.ImageName = igRes.ImageName
				}
				notifyData, err := json.Marshal(res)
				if err != nil {
					log.Logger.Warnf("Marshal Image Generation Response %v", err)
					break
				}
				serve.QueueLock.Lock()
				for i, item := range serve.RequestQueue {
					if item.ID == pmsg.Header.Id {
						item.Notify <- notifyData
						serve.RequestQueue = append(serve.RequestQueue[:i], serve.RequestQueue[i+1:]...)
						close(item.Notify)
						break
					}
				}
				serve.QueueLock.Unlock()
			} else {
				log.Logger.Warn("Message type and body do not match")
			}
		default:
			log.Logger.Warnf("Unknowned message type", pmsg.Type)
		}
	}
}
